<html>
    <head>
        <link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
        <link href="codemirror.css" rel="stylesheet" type="text/css"></link>
        <script src="codemirror.js" type="text/javascript"></script>
        <script src="javascript.js" type="text/javascript"></script>
        <link href="main.css" rel="stylesheet" type="text/css"></link>
        <script src="transit.js" type="text/javascript"></script>
    </head>
    <body>
        <center>
            <div class="container">
                <h2>A Tour of Transit</h2>
                <p>
                    This tour introduces
                    the <a href="http://transit-format.org">Transit</a>
                    format via
                    <a href="http://github.com/cognitect/transit-js">transit-js</a>,
                    an implementation of the Transit format for
                    JavaScript.
                </p>
                <p>
                    Transit implementations for other
                    languages may provide slightly different APIs that
                    reflect the idioms of the implementation language.
                    However, regardless of implementation, the
                    semantics of the format must be preserved.
                </p>
                <p>
                    The following is an interactive guide to
                    Transit. Press the <font class="eval">Eval</font> button
                    after each code snippet to evaluate it.
                </p>
                <p>
                    Each example is a
                    <a href="http://codemirror.net">CodeMirror</a> editor so that
                    you may edit and try out the transit-js API
                    youself:
                </p>
                <h3>Creating a Reader</h3>
                <p>
                    Transit implementations support encodings in
                    <a href="http://json.org">JSON</a>, <a href="http://msgpack.org">msgpack</a>,
                    or both. transit-js currently only supports
                    JSON. You can specify what type of reader you wish
                    to construct:
                </p>
                <textarea id="create">var r = transit.reader("json");</textarea>
                <button onclick="evaluate('create')">Eval</button>
                <h3>Reading Data</h3>
                <p>
                    Once a reader has been constructed you can read
                    transit wire data. All JSON is valid wire data for
                    transit JSON readers. Some Transit read
                    implementations take an encoded input stream, in
                    our case we simply take a string of encoded data:
                </p>
                <p>
                    We can read JavaScript strings, numbers, and
                    arrays as supported
                    by <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse</a>:
                </p>
                <textarea id="array-read">var r = transit.reader("json");
r.read("[1,1.5,1e5,\"A string!\",\"\u03BB\"]");</textarea>
                <button onclick="evaluate('array-read')">Eval</button>
                <p>
                    We can also read values not supported by JSON.parse:
                </p>
                <textarea id="read-dates">var r = transit.reader("json");
r.read("[\"~m0\",\"~m1\",\"~m2\"]");</textarea>
                <button onclick="evaluate('read-dates')">Eval</button>
                <p>
                    You can also read JavaScript objects:
                </p>
                <textarea id="map-read">var r = transit.reader("json");
var m = r.read("{\"foo\":\"bar\"}");
m["foo"]</textarea>
                <button onclick="evaluate('map-read')">Eval</button>
                <p>
                    Note that a plain JavaScript object was not
                    returned. JavaScript objects do not support
                    scalar values as keys beyond strings.
                </p>
                <textarea id="read-map">var r = transit.reader("json");
var m = r.read("{\"foo\":\"bar\"}");
m.get("foo")</textarea>
                <button onclick="evaluate('read-map')">Eval</button>
                <h3>Maps</h3>
                <p>
                    transit-js returns proper hash maps. transit-js
                    hash maps not only support the
                    proposed <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">ECMAScript
                    6 Map interface</a>, look up is based on value not
                    reference which subsumes and supercedes the
                    standard behavior.
                </p>
                <textarea id="complex-key">var m = transit.map([new Date(0), "Works!"]);
m.get(new Date(0));</textarea>
                <button onclick="evaluate('complex-key')">Eval</button>
                <p>
                    The above is impossible under the proposed ES6 Map
                    specification.
                </p>
                <p>
                    transit-js supports reading and writing maps with
                    richer keys - even including collection types like
                    JavaScript objects, arrays, and transit-js
                    maps. For example you can read a map with a date
                    key:
                </p>
                <textarea id="complex-key-read">var r = transit.reader("json");
var m = r.read("{\"~m0\":\"Works!\"}");
m.get(new Date(0));</textarea>
                <button onclick="evaluate('complex-key-read')">Eval</button>
                <h3>Creating a Writer</h3>
                <p>
                    Creating a Transit writer is similar to constructing
                    a reader:
                </p>
                <textarea id="writer">var w = transit.writer("json");</textarea>
                <button onclick="evaluate('writer')">Eval</button>
                <h3>Writing Data</h3>
                <p>
                    We can write permitted JSON values similar
                    to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify</a>:
                <p>
                <textarea id="write-array">var w = transit.writer("json");
w.write([1,1.5,1e500,"A string!","\u03BB"]);</textarea>
                <button onclick="evaluate('write-array')">Eval</button>
                <p>
                    We can also encode values not supported by JSON.stringify, for
                    example dates and 64 bit integer values:
                </p>
                <textarea id="write-dates">var w = transit.writer("json"),
   v0 = new Date(),
   v1 = transit.integer("9007199254740993");
w.write([v0,v1]);</textarea>
                <button onclick="evaluate('write-dates')">Eval</button>
                <p>
                    We can also encode map and map-like collection types:
                </p>
                <textarea id="write-map">var w = transit.writer("json"),
    m = {"foo": 1, "bar": 2};
w.write(m);</textarea>
                <button onclick="evaluate('write-map')">Eval</button>
                <p>
                    Notice that the map get written as a JavaScript
                    array. While this is more efficient it's also less
                    readable. You can construct a verbose writer to
                    get human readable output for debugging purposes:
                </p>
                <textarea id="write-map-verbose">var w = transit.writer("json-verbose"),
    m = {"foo": 1, "bar": 2};
w.write(m);</textarea>
                <button onclick="evaluate('write-map-verbose')">Eval</button>
                <h3>Caching</h3>
                <p>
                    Transit implementations cache repeated values on
                    read and write. This simple optimization allows
                    Transit implementations to compete with
                    traditional JSON encoder/decoder usage. For
                    example transit-js read can be up to 2X faster
                    than JSON.parse for the same logical data - this is
                    without forcing end users to understand how to
                    index into the payload themselves.
                </p>
                <textarea id="write-cache">var w = transit.writer("json"),
    d = [{"userCommentId": 9,
          "userUpvotes": 10},
         {"userCommentId": 0,
          "userUpvotes": 3},
         {"userCommentId": 1,
          "userUpvotes": 4},
         {"userCommentId": 4,
          "userUpvotes": 1},
         {"userCommentId": 3,
          "userUpvotes": 100}],
   ret = {json: JSON.stringify(d).length,
          transit: w.write(d).length};
ret;</textarea>
                <button onclick="evaluate('write-cache')">Eval</button>
                <h3>Extensible Reading & Writing</h3>
                <p>
                    One of the biggest drawbacks of JSON as a data
                    format is the lack of extensibility. Transit allows
                    users to customize both reading and writing.
                </p>
                <h4>Read handlers</h4>
                <p>
                    Transit readers can be customized with user
                    provided handlers. For example:
                </p>
                <textarea id="write-cache">var Point = function(x, y) {this.x=x;this.y=y},
    r     = transit.reader("json", {
              "handlers": {
                 "point": function(v) {
                    return new Point(v[0], v[1]);
                  }
              }
            });

r.read("[{\"~#point\":[0.5,1.5]}]");</textarea>
                <button onclick="evaluate('write-cache')">Eval</button>

                <h4>Write handlers</h4>
            </div>
        </center>

        <!-- Load Scripts -->
        <script src="out-dev/goog/base.js" type="text/javascript"></script>
        <script src="tour.js" type="text/javascript"></script>
        <script type="text/javascript">goog.require("tour.core");</script>
    </body>
</html>
