<html>
    <head>
        <link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css">
        <script src="http://cdnjs.cloudflare.com/ajax/libs/json3/3.3.2/json3.min.js" type="text/javascript"></script>
        <link href="resources/codemirror.css" rel="stylesheet" type="text/css"></link>
        <script src="resources/codemirror.js" type="text/javascript"></script>
        <script src="resources/javascript.js" type="text/javascript"></script>
        <link href="resources/main.css" rel="stylesheet" type="text/css"></link>
        <script src="resources/transit.js" type="text/javascript"></script>
    </head>
    <body>
        <center>
            <div class="container">
                <h2>A Tour of Transit</h2>
                <p>
                    This tour introduces
                    the <a href="http://transit-format.org">Transit</a>
                    format via
                    <a href="http://github.com/cognitect/transit-js">transit-js</a>,
                    an implementation of the Transit format for
                    JavaScript.
                </p>
                <p>
                    Transit implementations for other languages may
                    provide slightly different APIs that
                    reflect the idioms of the implementation language
                    and language specific performance
                    concerns. However, regardless of implementation,
                    the semantics of the format must be preserved.
                </p>
                <p>
                    The guide is interactive. Press
                    the <font class="eval">Eval</font> button after
                    each code snippet to evaluate it. Each example is
                    a
                    <a href="http://codemirror.net">CodeMirror</a>
                    editor so that you can edit and try out the
                    transit-js API youself:
                </p>
                <h3>Creating a Reader</h3>
                <p>
                    Transit implementations support encodings in
                    <a href="http://json.org">JSON</a>, <a href="http://msgpack.org">msgpack</a>,
                    or both. transit-js currently only supports
                    JSON. You can specify what type of reader you wish
                    to construct:
                </p>
                <textarea id="create">transit.reader("json");</textarea>
                <button onclick="evaluate('create')">Eval</button>
                <h3>Reading Data</h3>
                <p>
                    Once a reader has been constructed you can read
                    transit wire data. All JSON is valid wire data for
                    transit JSON readers. Some Transit <code>read</code>
                    implementations take an encoded input stream. In
                    the transit-js case <code>read</code> simply takes
                    a string of encoded data:
                </p>
                <p>
                    We can read JSON strings, numbers, and
                    arrays as supported
                    by <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse</a>:
                </p>
                <textarea id="array-read">var r = transit.reader("json");
r.read('[1,1.5,1e5,"A string!","\u03BB"]');</textarea>
                <button onclick="evaluate('array-read')">Eval</button>
                <p>
                    We can also read values not supported by
                    JSON.parse. This is possible by encoding values as
                    strings and using a simple tag convention. Transit
                    JSON strings that represent a scalar value are
                    prefixed with
                    <code>~</code> followed by single character. For
                    example the tag <code>~m</code> denotes a
                    non-verbose encoding of dates (human readable
                    dates can also be read/written).
                </p>
                <textarea id="read-dates">var r = transit.reader("json");
r.read('["~m0","~m1"]');</textarea>
                <button onclick="evaluate('read-dates')">Eval</button>
                <p>
                    For a full list of the scalar tags please refer to
                    the <a href="http://transit.org">Transit
                    specification</a>.
                </p>
                <p>
                    We've already seen that JSON arrays can be read,
                    but you can also read JSON objects. Note that
                    transit-js <code>read</code> returns proper
                    hash maps when reading objects because
                    JavaScript objects cannot support
                    scalar values beyond strings as keys.
                </p>
                <textarea id="read-map">var r = transit.reader("json"),
    m = r.read('{"foo":"bar"}');
m.get("foo")</textarea>
                <button onclick="evaluate('read-map')">Eval</button>
                <p>
                    This means that you can't dereference properties
                    using bracket notation, since they are not
                    plain JavaScipt objects:
                </p>
                <textarea id="map-read">var r = transit.reader("json"),
    m = r.read('{"foo":"bar"}');
m["foo"]</textarea>
                <button onclick="evaluate('map-read')">Eval</button>
                <p>
                    While this may initially seem less convenient
                    there are benefits to opting into returning maps
                    in transit-js.
                </p>
                <h3>Maps</h3>
                <p>
                    transit-js hash maps not only support the
                    proposed <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">ECMAScript
                    6 Map interface</a>, look up is based on value not
                    reference which subsumes the standard behavior.
                </p>
                <textarea id="complex-key">var m = transit.map([new Date(0), "Works!"]);
m.get(new Date(0));</textarea>
                <button onclick="evaluate('complex-key')">Eval</button>
                <p>
                    The above is impossible under the proposed ES6 Map
                    specification.
                </p>
                <p>
                    transit-js supports reading and writing maps with
                    richer keys including collection types like
                    JavaScript objects, arrays, and transit-js
                    maps. For example you can read a map with a date
                    key:
                </p>
                <textarea id="complex-key-read">var r = transit.reader("json"),
    m = r.read('{"~m0":"Works!"}');
m.get(new Date(0));</textarea>
                <button onclick="evaluate('complex-key-read')">Eval</button>
                <p>
                    transit-js maps and sets may be used &agrave;
                    la carte.  They have been written with performance
                    in mind and outperform existing ES6 Map/Set shims:
                </p>
                <textarea id="complex-key-read-2">var m = transit.map([{first:"John",last:"McCarthy"},
                     new Date(-1335729600000)]);

m.get({first:"John",last:"McCarthy"});</textarea>
                <button onclick="evaluate('complex-key-read-2')">Eval</button>
                <h3>Tagged Values</h3>
                <p>
                    Transit also supports non-scalar values beyond
                    arrays and maps via tagged values.  Tagged values
                    are represented on the wire as JSON objects with a
                    single key value pair. The object key is a tag - a
                    string prefixed with
                    <code>~#</code>. The value is a Transit value that
                    can be further interpreted by the tagged value
                    handler after being decoded by Transit itself.
                    Transit ships with several tagged values built in
                    including ES6 compliant sets:
                </p>
                <textarea id="tagged-read">var r = transit.reader("json"),
    s = r.read('{"~#set":["cat","dog","bird"]}');
s.has("bird");</textarea>
                <button onclick="evaluate('tagged-read')">Eval</button>
                <p>
                    Tagged values that have no user installed handler
                    will be handled by a default handler. This allows
                    sending data intact through heterogenous
                    independent systems that utilize Transit.
                </p>
                <h3>Creating a Writer</h3>
                <p>
                    Creating a Transit writer is similar to constructing
                    a reader:
                </p>
                <textarea id="writer">transit.writer("json");</textarea>
                <button onclick="evaluate('writer')">Eval</button>
                <h3>Writing Data</h3>
                <p>
                    We can serialize simple JavaScript values
                    as we would with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify</a>:
                <p>
                <textarea id="write-array">var w = transit.writer("json");
w.write([1,1.5,1e5,"A string!","\u03BB"]);</textarea>
                <button onclick="evaluate('write-array')">Eval</button>
                <p>
                    We can also encode values not supported by JSON.stringify, for
                    example dates and 64 bit integer values:
                </p>
                <textarea id="write-dates">var w  = transit.writer("json"),
    v0 = new Date(),
    v1 = transit.integer("9007199254740993"); // Math.pow(2,53)+1
w.write([v0,v1]);</textarea>
                <button onclick="evaluate('write-dates')">Eval</button>
                <p>
                    We can also encode map and map-like collection types:
                </p>
                <textarea id="write-map">var w = transit.writer("json"),
    m = {"foo": 1, "bar": 2};
w.write(m);</textarea>
                <button onclick="evaluate('write-map')">Eval</button>
                <p>
                    Notice the map is written as a JavaScript
                    array. While this may be more efficient it's also less
                    readable. You can construct a verbose writer to
                    get human readable output for debugging purposes:
                </p>
                <textarea id="write-map-verbose">var w = transit.writer("json-verbose"),
    m = {"foo": 1, "bar": 2};
w.write(m);</textarea>
                <button onclick="evaluate('write-map-verbose')">Eval</button>
                <h3>Extensible Reading & Writing</h3>
                <p>
                    One of the biggest drawbacks of JSON as a data
                    format is the lack of extensibility. Transit allows
                    users to customize both reading and writing.
                </p>
                <h4>Read handlers</h4>
                <p>
                    Transit readers can be customized with user
                    provided handlers. For example:
                </p>
                <textarea id="read-handler">var Point = function(x, y) {this.x=x;this.y=y},
    r     = transit.reader("json", {
              "handlers": {
                 "point": function(v) {
                    return new Point(v[0], v[1]);
                  }
              }
            });

r.read('[{"~#point":[0.5,1.5]}]');</textarea>
                <button onclick="evaluate('read-handler')">Eval</button>
                <h4>Write handlers</h4>
                <p>
                    Transit writers can similarly be extended to handle
                    custom types:
                </p>
                <textarea id="write-handler">var Point = function(x, y) {this.x=x;this.y=y},
    ph    = transit.makeWriteHandler({
              tag: function(v) { return "point"; },
              rep: function(v) { return [v.x, v.y]; },
              stringRep: function(v) { return null; }
            }),
    w     = transit.writer("json", {
              "handlers": transit.map([Point, ph])
            });

w.write([new Point(0.5,1.5),new Point(1.5,2.5)]);</textarea>
                <button onclick="evaluate('write-handler')">Eval</button>
                <p>
                    You may be wondering where the <code>^!</code>
                    came from, this is an artifact of caching.
                </p>
                <h3>Caching</h3>
                <p>
                    Transit implementations cache map keys, transit
                    symbols, transit keywords, and tagged value tags
                    on read and write. This simple optimization allows
                    Transit implementations to compete with
                    traditional JSON encoder/decoder usage -
                    transit-js read can be nearly 2X faster than
                    JSON.parse under some JavaScript engines for the
                    same logical data:
                </p>
                <textarea id="write-cache-simple">var w = transit.writer("json"),
    d = [{"userId": 0}, {"userId": 1}];
w.write(d);</textarea>
                <button onclick="evaluate('write-cache-simple')">Eval</button>
                <p>
                    As the redundancy in the data grows, caching delivers
                    increasingly compact results.
                </p>
                <textarea id="write-cache">var w   = transit.writer("json"),
    d   = [{"userCommentId": 9,
            "userUpvotes": 10},
           {"userCommentId": 0,
            "userUpvotes": 3},
           {"userCommentId": 1,
            "userUpvotes": 4},
           {"userCommentId": 4,
            "userUpvotes": 1},
           {"userCommentId": 3,
            "userUpvotes": 100}],
    ret = {json: JSON.stringify(d).length,
           transit: w.write(d).length};
ret;</textarea>
                <button onclick="evaluate('write-cache')">Eval</button>
            </div>
        </center>

        <!-- Load Scripts -->
        <!-- <script src="resources/out-dev/goog/base.js" type="text/javascript"></script> -->
        <script src="resources/tour.js" type="text/javascript"></script>
        <!-- <script type="text/javascript">goog.require("tour.core");</script> -->
    </body>
</html>
